<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何root小米手机]]></title>
    <url>%2F2020%2F02%2F01%2F%E5%A6%82%E4%BD%95root%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[#手把手教你如何root自己的手机 ####由于我的手机是小米mix2s这里就以小米手机为例，教大家如何root自己的安卓手机 现在的手机root很方便只需点击手机管家，然后点击应用管理再打开右上角的权限就可以看见下面有权限管理。如下图所示 但是 一般的手机点进来是只有前面三个选项，因为第四个选项只有开发版的系统才会显示 ###所以我们只需将我们的系统版本由稳定版刷成开发版即可(以miui为例) 首先我们需要从官网上下载对应自己手机的开发版系统。百度搜索miui，点击下载，选择合适自己手机的系统，选择开发者版本点击下载。 若使用电脑下载的手机系统安装包，则需要将手机连接电脑(手机连接电脑时，需注意先将手机调成开发者模式)点击开发者选项，滑到调试的一栏。打开usb调试允许usb安装。 #######注意：继续往下翻，找到usb默认设置。选择传输文件(MTP),此时才算成功连接电脑(我的手机这里是默认仅限充电，无法在电脑上显示手机设备)连接电脑成功后，将下载好的系统zip文件拷贝到手机的download_row文件夹下。 ###在手机上的操作：点击设置，我的设备。点击最上面的MIUI版本，点击右上角的三个小点。选择手动选择安装包。选择download_row文件夹下的系统zip,点击确认即可 此步如果没有手动选择安装包选项，需要点击此页面的MIUI图片十次 #注意： 刷机前一定要保持电量充足，如果刷机时手机没电会导致手机无法开机。 一定要注意数据备份，小米手机可以使用小米的云服务备份软件和相册等数据。但是自己软件里的信息要注意自己备份，我手机里的todolist里的数据因为没有云备份，刷机时被擦除就无法找回了。 将手机系统刷成开发版之后依然不能解除root，会显示手机没有解锁。这时需要登录 www.unlock.update.miui.com 下载小米官方的解锁工具。之后打开手机点击设置，更多设置，开发者选项，在设备解锁状态中绑定小米账号和设备。绑定完成后将手机关机同时按住开机键和音量下键，手动进入 bootloader 模式。在电脑上打开官方解锁工具，将手机与电脑相连。点击解锁按钮，即可解锁成功，解锁成功后点击重启手机。此时完成解锁后的手机是可以解除root的。 ######最后root有风险，刷机需谨慎。前几天由于某些原因自己需要root一下手机，也在网上找了好多方法，走了好多弯路。成功之后把自己如何root的过程记录一下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F11%2F19%2Ftest%2F</url>
    <content type="text"><![CDATA[###可视化实验设计]]></content>
  </entry>
  <entry>
    <title><![CDATA[用python将数据导入excel文件中]]></title>
    <url>%2F2018%2F09%2F21%2F%E7%94%A8python%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5excel%E6%96%87%E4%BB%B6%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[前几天帮一个做数学建模的大佬编了一小段程序，算法、数据都是他计算好发给我的。本来这用c++就可以解决了，但是他还要求从excel中读写数据，所以我最终决定还是python大法好。 由于这个问题中涉及到二维数组的问题，而python中并没有直接定义二维数组这个概念，所以我们自己创建并初始化一个二维列表来充当二维数组nums = [] #定义一个列表用于生成二维列表shuju = [] #定义一个数据列表用于存入excel中rows = 1646 #二维列表的行数columns = 1520 #二维列表的列数#用0初始化二维列表for row in range(rows): nums.append([]) for column in range(columns): nums[row].append(0) 往数组中填入数据for column in range(columns): #用循环将第0行全部赋值为48.08 nums[0][column] = 48.08 #print nums[0][column] for row in range(1,rows): #用循环将第0列所有行赋值为75 nums[row][0] = 75 然后我们要从excel中获取一些数据来对矩阵进行初始化操作，所以这里我们先引入python中的xlrd模块1、常用单元格中的数据类型 0 empty,1 string（text）, 2 number, 3 date, 4 boolean, 5 error， 6 blank 2、导入模块 import xlrd3、打开Excel文件读取数据 data = xlrd.open_workbook(filename) 本文来自 echo_Ae 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/echo_ae/article/details/78693380?utm_source=copy #导入xlrd模块。xls文件read库，只能读。若写入，要用xlwt，意为:xls文件write写入库。可以实现指定表单、指定单元格的读取。import xlrdfile = 'biao.xlsx' #excel文件名wb = xlrd.open_workbook(filename=file) #打开excel文件获取数据ws = wb.sheet_by_name('Sheet') #通过名称获取表格对象j = 1645 #定义二维列表最后一行的下标for i in range(2,1647): #用循环将excel表中一列的数据读入到二维列表的最后一列 nums[j][1519] = ws.cell(i,1).value #print i #print nums[j][1519] j = j-1 #print j #print '\n' 接下来数组初始化完毕以后我们开始计算我们需要得到的结果#用循环计算数据的值for i in range(1,rows): for j in range(1,columns-1): #D:nums[i][j],A:nums[i-1][j-1],B:nums[i-1][j],C:nums[i-1][j+1] #D = 7.94e-3*(C+A)+B*(1-2*7.94e-3) nums[i][j] = 7.94e-3*float((nums[i-1][j+1]+nums[i-1][j-1]))+float(nums[i-1][j])*float(1-2*7.94e-3) 到这里这个问题基本已经解决了，但是还有一个问题，我们需要把计算完的数据按照倒序存入excel表中。一开始我想用xlwt模块来实现将数据写入excel中，但是实际操作时却发现了这个模块的局限性。这个模块存入数据时最多只能存256列，可是我们需要存入一千多列。问了度娘后我发现网上的大神都是这么解决这个问题的。#!/usr/bin/python# -*- coding:utf8 -*- import xlwt def write_data_to_excel(): print '开始生成' wbk = xlwt.Workbook() sheets = [] sheet = wbk.add_sheet('Sheet1',cell_overwrite_ok=True) sheets.append(sheet) for i in xrange(500): print '正在生成：第'+str(i+1)+'条数据 . . .' for j in xrange(769): #计算第几个表 scount=j/256 #如果表的个数少于该有的个数，则新建 if(len(sheets) &lt;= scount): sheets.append(wbk.add_sheet('Sheet'+str(scount+1),cell_overwrite_ok=True)) #计算第几列，如果是256的倍数，序号应从0开始 col = j % 256 sheets[scount].write(i,col,str(j)) wbk.save('test.xls') print '生成成功' if __name__ == '__main__': write_data_to_excel() 本文来自 密斯特尔佳 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/u013608482/article/details/80942427?utm_source=copy 即当写入的数据超过256列时就创建多张表。可是我又不想创建几张表，于是我解锁了新功能:python的csv模块。csv模块就完全没有上述问题，而且是python内置，简直是居家必备。Python处理csv文件CSV(Comma-Separated Values)即逗号分隔值，可以用Excel打开查看。由于是纯文本，任何编辑器也都可打开。与Excel文件不同，CSV文件中：值没有类型，所有值都是字符串不能指定字体颜色等样式不能指定单元格的宽高，不能合并单元格没有多个工作表不能嵌入图像图表在CSV文件中，以,作为分隔符，分隔两个单元格。像这样a,,c表示单元格a和单元格c之间有个空白的单元格。依此类推。不是每个逗号都表示单元格之间的分界。所以即使CSV是纯文本文件，也坚持使用专门的模块进行处理。Python内置了csv模块。 所以说了这么多其实在使用城市v、模块时只需要三行代码就可以把几千万个数据存入excel中了#import xlwt 由于用xlwt写入excel时，最多只能写入256列，无法存入所有数据。所以改用csv操作import csv#将nums的值按顺序存入shuju中k = 1645 #将nums的最后一行存入shuju的第一行for row in range(rows): shuju.append([]) for column in range(columns): shuju[row].append(nums[k][column]) k = k-1 #csv写入#打开文件with open("shuju.csv","wb") as csvfile: writer = csv.writer(csvfile)#写入多行用writerows writer.writerows(shuju)]]></content>
  </entry>
  <entry>
    <title><![CDATA[说明]]></title>
    <url>%2F2018%2F09%2F14%2F%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[欢迎大家访问小龙的个人博客,以后这里就是我的小窝啦,希望大家多来看看我鸭。（这个博客暂时还未实现任何功能） 虽然功能没有但是本着既然来了就不能让dalao白来的原则小弟在这粘一段从其他dalao抄来的以词云的方式统计微信好友情况的代码吧import itchatimport numpy as npfrom os import pathfrom wordcloud import WordCloud, STOPWORDS, ImageColorGeneratorfrom PIL import Imageimport randomimport osimport reimport matplotlib.pyplot as pltimport ioimport jieba'''itchat.auto_login(hotReload = True)# 爬取自己好友的相关信息, 返回一个json文件friends = itchat.get_friends(update = True)[0:]'''def parse_friends(): itchat.login() text = dict() friends = itchat.get_friends(update = True) male = "male" female = "female" other = "other" for i in friends[1:]: sex = i['Sex'] if sex == 1: text[male] = text.get(male, 0) + 1 #dict.get(key,default)返回键的值, 若不存在则返回default elif sex == 2: text[female] = text.get(female, 0) + 1 else: text[other] = text.get(other, 0) + 1 total = len(friends[1:]) print("男性好友: %.2f%%" % (float(text[male]) / total *100) + "\n" + "女性好友: %.2f%%" % (float(text[female]) / total *100) + "\n" + "不明性别好友: %.2f%%" % (float(text[other]) / total *100) ) draw(text)def draw(datas): for key in datas.keys(): plt.bar(key, datas[key]) plt.legend() plt.xlabel('sex') plt.ylabel('rate') plt.title("Gender of Alfred's friends") plt.show() def parse_signature(): itchat.auto_login(hotReload = True) siglist = [] friends = itchat.get_friends(update = True)[1:] for i in friends: signature = i["Signature"].strip().replace("span", "").replace("class", "").replace("emoji", "") rep = re.compile("1f\d+\w*|[&lt;&gt;/=]") signature = rep.sub("", signature) siglist.append(signature) text = "".join(siglist) with io.open('text.txt', 'w', encoding = 'utf-8') as f: wordlist = jieba.cut(text, cut_all = True) word_space_split = " ".join(wordlist) f.write(word_space_split) f.close() def draw_signature(): text = open(u'text.txt', encoding ='utf-8').read() coloring = np.array(Image.open('jingqi_de_katong_dongwu-005.jpg')) my_wordcloud = WordCloud(background_color = "white", max_words = 2000, mask = coloring, max_font_size = 60, random_state = 42, scale = 2, font_path = "DroidSansFallbackFull.ttf").generate(text) image_colors = ImageColorGenerator(coloring) plt.imshow(my_wordcloud.recolor(color_func = image_colors)) plt.imshow(my_wordcloud) plt.axis("off") plt.savefig("D:/PyProgram/cloud.jpg", dpi = 200) # 如果savefig放在plt.show()后面会造成保存空白图的问题 plt.show() #parse_friends()#parse_signature()#draw_signature() 最后还是给大家劈个叉，祝各位晚安吧。 未完待续….]]></content>
  </entry>
</search>
